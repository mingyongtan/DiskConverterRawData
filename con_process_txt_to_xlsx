#!/usr/bin/env python3
"""
Disk I/O TXT → Excel Converter (GUI + CLI)
=========================================

Parses raw text (tab- or multi-space-separated) with columns like:

    Process    PID    I/O Read Bytes    I/O Write Bytes    I/O Other Bytes
    StartMenuExperienceHost.exe  7404  4.6 MB  120.3 KB  93.0 KB

Outputs an Excel workbook where **each input TXT** is written to its **own
sheet** (named from the file), with:
  • The original columns (human-readable units kept as-is)
  • A numeric **Total Bytes (B)** column computed from the three I/O columns
  • **Cumulative Total Bytes** (SUM of Total Bytes) as an Excel formula (A1)
  • **Total Usage of I/O in 100%** as an Excel formula (A1), formatted as %

Why A1 formulas?
  Structured references sometimes make Excel "repair" the workbook when created
  by libraries. Using A1 formulas is the most robust across Excel builds.

Try quickly:
  python disk_parser.py --run-tests
GUI:
  python disk_parser.py
CLI (multi-file):
  python disk_parser.py --cli -i a.txt b.txt -o io_report.xlsx
"""
from __future__ import annotations

import argparse
import os
import re
import sys
from typing import Dict, List, Optional, Tuple

# ──────────────────────────────────────────────────────────────────────────────
# Optional GUI deps — we gracefully fall back to CLI if Tk isn't present.
# ──────────────────────────────────────────────────────────────────────────────
try:  # Some Python installs omit Tk
    import tkinter as tk  # type: ignore
    from tkinter import ttk, filedialog, messagebox  # type: ignore
    TK_OK = True
except Exception:  # pragma: no cover (environment-dependent)
    TK_OK = False


# ──────────────────────────────────────────────────────────────────────────────
# Parsing helpers
# ──────────────────────────────────────────────────────────────────────────────
HEADER_NAMES = [
    "Process",
    "PID",
    "I/O Read Bytes",
    "I/O Write Bytes",
    "I/O Other Bytes",
]
# Skip any rows with these process names (case-insensitive)
DROP_PROCESSES = {"procexp64.exe"}

TAB_RE = re.compile(r"\t+")                 # split on one or more tabs
MULTISPACE_SPLIT = re.compile(r"\s{2,}")    # or on 2+ spaces (common in copy/paste)
QUOTES_RE = re.compile(r'"')                 # strip accidental quotes
UNIT_RE = re.compile(r"(?i)^\s*([0-9]*\.?[0-9]+)\s*([KMGT]?B)\s*$")

UNIT_MULT = {  # bytes multipliers (decimal KB=1024 because source is binary-ish)
    "B": 1,
    "KB": 1024,
    "MB": 1024 ** 2,
    "GB": 1024 ** 3,
    "TB": 1024 ** 4,
}


def _clean_line(line: str) -> str:
    """Normalize a single input line (trim, drop BOM/quotes)."""
    line = line.replace("\ufeff", "").replace("ï»¿", "")
    return QUOTES_RE.sub("", line.strip())


def _tokenize(line: str) -> List[str]:
    """Split by tabs first; fallback to ≥2 spaces if that looks better."""
    raw = _clean_line(line)
    if not raw:
        return []
    toks = [t.strip() for t in TAB_RE.split(raw) if t.strip()]
    if len(toks) <= 1:
        toks = [t.strip() for t in MULTISPACE_SPLIT.split(raw) if t.strip()]
    return toks


def _looks_like_header(tokens: List[str]) -> bool:
    """Heuristically detect header rows (even if repeated inside the data)."""
    if not tokens:
        return False
    norm = [t.lower() for t in tokens]
    if len(norm) >= 3 and norm[0].startswith("process") and ("read" in " ".join(norm)):
        return True
    # If the token set is a subset of known header names, treat as header
    return set(t.capitalize() for t in tokens) <= set(HEADER_NAMES)


def _parse_bytes(s: str) -> int:
    """Parse a human-readable size like "4.6 MB" → bytes (int).

    - Accepts B, KB, MB, GB, TB (case-insensitive)
    - Tolerates stray commas or missing unit (then assumes bytes)
    - Returns 0 on failure
    """
    if not s:
        return 0
    s = s.replace(",", "").strip()
    m = UNIT_RE.match(s)
    if m:
        value = float(m.group(1))
        unit = m.group(2).upper()
        mult = UNIT_MULT.get(unit, 1)
        return int(value * mult)
    # Fallback: plain integer/float string without unit
    try:
        return int(float(s))
    except Exception:
        return 0


def parse_disk_text(raw: str) -> List[Dict[str, object]]:
    """Parse I/O rows into dicts.

    Handles cases where a process name contains spaces by assuming the *last 4*
    tokens are PID + three I/O columns; everything before is the process name.
    """
    rows: List[Dict[str, object]] = []
    for line in raw.splitlines():
        line = _clean_line(line)
        if not line:
            continue
        tokens = _tokenize(line)
        if not tokens:
            continue
        if _looks_like_header(tokens):
            continue

        if len(tokens) < 5:
            continue  # not enough fields to form a row
        if len(tokens) > 5:
            # Reassemble process name: all tokens except the last 4
            proc = " ".join(tokens[:-4])
            pid, r, w, o = tokens[-4:]
        else:
            proc, pid, r, w, o = tokens

        # Drop invalid/noisy processes globally
        if proc.strip().lower() in DROP_PROCESSES:
            continue

        row = {
            "Process": proc,
            "PID": int(pid) if pid.isdigit() else 0,
            "I/O Read Bytes": r,
            "I/O Write Bytes": w,
            "I/O Other Bytes": o,
        }
        rows.append(row)

    return rows


# ──────────────────────────────────────────────────────────────────────────────
# Calculations for preview + Excel formulas later
# ──────────────────────────────────────────────────────────────────────────────
EXTRA_HEADERS = [
    "Total Bytes (B)",
    "Cumulative Total Bytes",
    "Total Usage of I/O in 100%",
]
HEADERS = HEADER_NAMES + EXTRA_HEADERS


def add_calculated_columns(rows: List[Dict[str, object]]) -> List[Dict[str, object]]:
    """Add Total Bytes now so the preview can show percentages accurately."""
    out: List[Dict[str, object]] = []
    for r in rows:
        read_b = _parse_bytes(str(r.get("I/O Read Bytes", "")))
        write_b = _parse_bytes(str(r.get("I/O Write Bytes", "")))
        other_b = _parse_bytes(str(r.get("I/O Other Bytes", "")))
        total = read_b + write_b + other_b
        rr = dict(r)
        rr["Total Bytes (B)"] = total
        out.append(rr)

    # Compute percentages for preview only (Excel will re-evaluate using formulas)
    grand = sum(int(x["Total Bytes (B)"]) for x in out) or 0
    for r in out:
        r["Cumulative Total Bytes"] = grand
        r["Total Usage of I/O in 100%"] = (r["Total Bytes (B)"] / grand) if grand else 0.0
    return out


# ──────────────────────────────────────────────────────────────────────────────
# Excel writing utilities
# ──────────────────────────────────────────────────────────────────────────────

def _ensure_openpyxl():
    try:
        from openpyxl import Workbook, load_workbook  # noqa: F401
        from openpyxl.worksheet.table import Table, TableStyleInfo  # noqa: F401
        from openpyxl.utils import get_column_letter  # noqa: F401
    except Exception as e:  # pragma: no cover
        raise RuntimeError("openpyxl is required. Install with: pip install openpyxl") from e


SAFE_SHEET_BAD = re.compile(r"[:\\/\?*\[\]]")
SAFE_TABLE_BAD = re.compile(r"[^A-Za-z0-9_]")


def safe_sheet_name(base: str, used: Optional[set] = None) -> str:
    name = SAFE_SHEET_BAD.sub("_", (base or "Sheet").strip())[:31] or "Sheet"
    if used is None:
        return name
    cand = name
    i = 2
    while cand in used:
        suf = f" ({i})"
        cand = (name[: 31 - len(suf)] + suf)
        i += 1
    used.add(cand)
    return cand


def safe_table_name(base: str, used: Optional[set] = None) -> str:
    name = SAFE_TABLE_BAD.sub("_", base or "T")
    if not name or not name[0].isalpha():
        name = "T_" + name
    if used is None:
        return name
    cand = name
    i = 2
    while cand in used:
        cand = f"{name}_{i}"
        i += 1
    used.add(cand)
    return cand


def _autosize(ws) -> None:
    from openpyxl.utils import get_column_letter as _col
    last_row = ws.max_row
    last_col = ws.max_column
    for c in range(1, last_col + 1):
        mx = 0
        for r in range(1, last_row + 1):
            v = ws.cell(r, c).value
            if v is None:
                continue
            mx = max(mx, len(str(v)))
        ws.column_dimensions[_col(c)].width = min(max(mx + 2, 12), 60)


def _inject_formulas_a1(ws) -> None:
    """Add A1-style formulas for cumulative + per-row %.

    We avoid structured references to keep Excel from "repairing" the file in
    some versions.
    """
    from openpyxl.utils import get_column_letter as _col
    hdr_idx: Dict[str, int] = {ws.cell(1, i).value: i for i in range(1, ws.max_column + 1)}

    col_total = hdr_idx.get("Total Bytes (B)")
    col_cum = hdr_idx.get("Cumulative Total Bytes")
    col_pct = hdr_idx.get("Total Usage of I/O in 100%")
    if col_total is None or col_cum is None or col_pct is None:
        return  # headers missing (renamed?) — nothing to do

    last_row = ws.max_row
    total_letter = _col(col_total)
    total_range = f"${total_letter}$2:${total_letter}${last_row}"
    cum_letter = _col(col_cum)

    for r in range(2, last_row + 1):
        # Cumulative total is the same formula on every row
        ws.cell(r, col_cum).value = f"=SUM({total_range})"
        ws.cell(r, col_cum).number_format = "#,##0"
        # Per-row percentage = row total / cumulative
        ws.cell(r, col_pct).value = f"=IF({cum_letter}{r}=0,0,{total_letter}{r}/{cum_letter}{r})"
        ws.cell(r, col_pct).number_format = "0.00%"


# Single-sheet writer (used by CLI for single file or GUI save)

def write_disk_sheet(rows_base: List[Dict[str, object]], out_path: str, sheet_name: str = "DiskIO") -> str:
    _ensure_openpyxl()
    from openpyxl import Workbook, load_workbook
    from openpyxl.worksheet.table import Table, TableStyleInfo
    from openpyxl.utils import get_column_letter

    if not rows_base:
        raise ValueError("No data parsed from input text.")

    if not out_path.lower().endswith(".xlsx"):
        out_path = out_path + ".xlsx"

    rows = add_calculated_columns(rows_base)

    if os.path.exists(out_path):
        wb = load_workbook(out_path)
        if sheet_name in wb.sheetnames:
            del wb[sheet_name]
        ws = wb.create_sheet(title=sheet_name)
    else:
        wb = Workbook()
        default = wb.active
        wb.remove(default)
        ws = wb.create_sheet(title=sheet_name)

    # Write header + rows
    ws.append(HEADERS)
    for r in rows:
        ws.append([r.get(h, "") for h in HEADERS])

    # Style as a table
    last_row = ws.max_row
    last_col = ws.max_column
    ref = f"A1:{get_column_letter(last_col)}{last_row}"

    # Unique table name across workbook
    existing = set()
    for _ws in wb.worksheets:
        try:
            if getattr(_ws, "tables", None) and isinstance(_ws.tables, dict):
                existing.update(t.displayName for t in _ws.tables.values())
            elif getattr(_ws, "_tables", None):
                existing.update(t.displayName for t in _ws._tables)
        except Exception:
            pass
    tname = safe_table_name(f"T_{sheet_name}", existing)

    table = Table(displayName=tname, ref=ref)
    table.tableStyleInfo = TableStyleInfo(name="TableStyleMedium9", showFirstColumn=False,
                                          showLastColumn=False, showRowStripes=True, showColumnStripes=False)
    ws.add_table(table)

    # Formats + panes
    ws.freeze_panes = "A2"
    hdr_idx: Dict[str, int] = {ws.cell(1, i).value: i for i in range(1, last_col + 1)}

    for name in ("PID",):
        idx = hdr_idx.get(name)
        if idx:
            for r in range(2, last_row + 1):
                ws.cell(r, idx).number_format = "#,##0"
    for name in ("Total Bytes (B)", "Cumulative Total Bytes"):
        idx = hdr_idx.get(name)
        if idx:
            for r in range(2, last_row + 1):
                ws.cell(r, idx).number_format = "#,##0"
    idx = hdr_idx.get("Total Usage of I/O in 100%")
    if idx:
        for r in range(2, last_row + 1):
            ws.cell(r, idx).number_format = "0.00%"

    # Inject formulas now that the table exists
    _inject_formulas_a1(ws)
    _autosize(ws)

    wb.save(out_path)
    return out_path


# Multi-file writer — one sheet per TXT

def write_workbook_for_files(file_paths: List[str], out_path: str) -> str:
    _ensure_openpyxl()
    from openpyxl import Workbook

    if not out_path.lower().endswith(".xlsx"):
        out_path = out_path + ".xlsx"

    wb = Workbook()
    default = wb.active
    wb.remove(default)

    used_sheets: set = set()
    for pth in file_paths:
        try:
            with open(pth, "r", encoding="utf-8", errors="replace") as f:
                raw = f.read()
            base_rows = parse_disk_text(raw)
            if not base_rows:
                continue
            rows = add_calculated_columns(base_rows)
            sname = safe_sheet_name(os.path.splitext(os.path.basename(pth))[0], used_sheets)
            # Create the sheet and write
            from openpyxl.worksheet.table import Table, TableStyleInfo
            from openpyxl.utils import get_column_letter
            ws = wb.create_sheet(title=sname)
            ws.append(HEADERS)
            for r in rows:
                ws.append([r.get(h, "") for h in HEADERS])
            last_row = ws.max_row
            last_col = ws.max_column
            ref = f"A1:{get_column_letter(last_col)}{last_row}"
            tname = safe_table_name(f"T_{sname}")
            table = Table(displayName=tname, ref=ref)
            table.tableStyleInfo = TableStyleInfo(name="TableStyleMedium9", showFirstColumn=False,
                                                  showLastColumn=False, showRowStripes=True, showColumnStripes=False)
            ws.add_table(table)
            ws.freeze_panes = "A2"
            _inject_formulas_a1(ws)
            _autosize(ws)
        except Exception:
            continue

    wb.save(out_path)
    return out_path


# ──────────────────────────────────────────────────────────────────────────────
# Minimal GUI (if Tk is available)
# ──────────────────────────────────────────────────────────────────────────────
if TK_OK:
    class App(tk.Tk):
        def __init__(self) -> None:
            super().__init__()
            self.title("Disk I/O TXT → Excel (DiskIO)")
            self.geometry("1100x720")

            self.rows_base: List[Dict[str, object]] = []
            self.rows_calc: List[Dict[str, object]] = []
            self.single_path: Optional[str] = None
            self.multi_files: List[str] = []

            self._build()

        def _build(self) -> None:
            pad = 8
            root = ttk.Panedwindow(self, orient=tk.VERTICAL)
            root.pack(fill=tk.BOTH, expand=True)

            top = ttk.Frame(root, padding=pad)
            root.add(top, weight=3)
            buttons = ttk.Frame(top)
            buttons.pack(fill=tk.X)
            ttk.Button(buttons, text="Load .txt", command=self.on_load).pack(side=tk.LEFT, padx=(0, pad))
            ttk.Button(buttons, text="Load .txt (multi)", command=self.on_load_multi).pack(side=tk.LEFT, padx=(0, pad))
            ttk.Button(buttons, text="Parse → Preview", command=self.on_parse).pack(side=tk.LEFT, padx=(0, pad))
            ttk.Button(buttons, text="Save as Excel", command=self.on_save).pack(side=tk.LEFT, padx=(0, pad))
            ttk.Button(buttons, text="Clear", command=lambda: self._set_text("")).pack(side=tk.LEFT)

            self.status = tk.StringVar()
            ttk.Label(buttons, textvariable=self.status, foreground="#0a7d11").pack(side=tk.LEFT, padx=(pad, 0))

            ttk.Label(top, text="Paste your Disk I/O text below (or use Load):").pack(anchor="w", pady=(pad, 0))
            self.txt = tk.Text(top, height=14, wrap="none")
            self.txt.pack(fill=tk.BOTH, expand=True)
            sx = ttk.Scrollbar(top, orient="horizontal", command=self.txt.xview)
            sy = ttk.Scrollbar(top, orient="vertical", command=self.txt.yview)
            self.txt.configure(xscrollcommand=sx.set, yscrollcommand=sy.set)
            sy.place(relx=1.0, rely=0.25, relheight=0.5, anchor="ne")
            sx.pack(fill=tk.X)

            bottom = ttk.Frame(root, padding=pad)
            root.add(bottom, weight=2)
            ttk.Label(bottom, text="Preview:").pack(anchor="w")

            self.tree = ttk.Treeview(bottom, columns=HEADERS, show="headings")
            for h in HEADERS:
                self.tree.heading(h, text=h)
                base = 260 if h == "Process" else 160
                if h in ("Total Bytes (B)", "Cumulative Total Bytes"):
                    base = 200
                if h == "Total Usage of I/O in 100%":
                    base = 180
                self.tree.column(h, width=base, anchor="w")
            self.tree.pack(fill=tk.BOTH, expand=True)
            sy2 = ttk.Scrollbar(bottom, orient="vertical", command=self.tree.yview)
            sx2 = ttk.Scrollbar(bottom, orient="horizontal", command=self.tree.xview)
            self.tree.configure(yscrollcommand=sy2.set, xscrollcommand=sx2.set)
            sy2.pack(side=tk.RIGHT, fill=tk.Y)
            sx2.pack(side=tk.BOTTOM, fill=tk.X)

        def _set_text(self, txt: str) -> None:
            self.txt.delete("1.0", tk.END)
            self.txt.insert("1.0", txt)
            self.rows_base = []
            self.rows_calc = []
            for item in self.tree.get_children():
                self.tree.delete(item)
            self.status.set("")

        def on_load(self) -> None:
            path = filedialog.askopenfilename(title="Open Text File", filetypes=[("Text files", "*.txt;*.log;*.*")])
            if not path:
                return
            try:
                with open(path, "r", encoding="utf-8", errors="replace") as f:
                    data = f.read()
                self._set_text(data)
                self.status.set("Loaded: " + os.path.basename(path))
                self.single_path = path
                self.multi_files = []
            except Exception as e:
                messagebox.showerror("Error", "Failed to load file " + str(e))

        def on_load_multi(self) -> None:
            paths = filedialog.askopenfilenames(title="Open Multiple Text Files", filetypes=[("Text files", "*.txt;*.log;*.*")])
            if not paths:
                return
            try:
                chunks = []
                for p in paths:
                    with open(p, "r", encoding="utf-8", errors="replace") as f:
                        chunks.append(f.read())
                self._set_text("\n".join(chunks))
                self.status.set(f"Loaded {len(paths)} files")
                self.multi_files = list(paths)
                self.single_path = None
            except Exception as e:
                messagebox.showerror("Error", "Failed to load files " + str(e))

        def on_parse(self) -> None:
            raw = self.txt.get("1.0", tk.END).strip()
            if not raw:
                messagebox.showwarning("No input", "Paste your text or use Load first.")
                return
            try:
                self.rows_base = parse_disk_text(raw)
                self.rows_calc = add_calculated_columns(self.rows_base)
                self._refresh(self.rows_calc)
                self.status.set("Parsed " + str(len(self.rows_calc)) + " rows")
            except Exception as e:
                messagebox.showerror("Parse failed", str(e))

            
        def _refresh(self, rows: List[Dict[str, object]]) -> None:
            def fmt(h: str, v) -> str:
                try:
                    if h in ("Total Bytes (B)", "Cumulative Total Bytes"):
                        return f"{int(v):,}"
                    if h == "Total Usage of I/O in 100%":
                        return f"{float(v)*100:.2f}%"
                    if h == "PID":
                        return f"{int(v):,}"
                except Exception:
                    pass
                return "" if v is None else str(v)

            for item in self.tree.get_children():
                self.tree.delete(item)
            self.tree["columns"] = list(HEADERS)

            widths = {h: len(h) for h in HEADERS}
            display: List[List[str]] = []
            for r in rows:
                vals = [fmt(h, r.get(h, "")) for h in HEADERS]
                display.append(vals)
                for h, dv in zip(HEADERS, vals):
                    widths[h] = max(widths[h], len(str(dv)))
            for h in HEADERS:
                base = 300 if h == "Process" else 180
                if h in ("Total Bytes (B)", "Cumulative Total Bytes"):
                    base = 200
                if h == "Total Usage of I/O in 100%":
                    base = 180
                w = max(120, min(base, widths[h] * 9))
                self.tree.heading(h, text=h)
                self.tree.column(h, width=w, anchor="w")
            for vals in display:
                self.tree.insert("", tk.END, values=vals)

        def on_save(self) -> None:
            if not self.rows_base and not self.multi_files:
                raw = self.txt.get("1.0", tk.END).strip()
                if not raw:
                    messagebox.showwarning("No input", "Nothing to save. Paste/load text, then Parse.")
                    return
                try:
                    self.rows_base = parse_disk_text(raw)
                except Exception as e:
                    messagebox.showerror("Parse failed", str(e))
                    return

            path = filedialog.asksaveasfilename(title="Save Excel Workbook", defaultextension=".xlsx", filetypes=[("Excel Workbook", "*.xlsx")])
            if not path:
                return

            try:
                if self.multi_files:
                    out = write_workbook_for_files(self.multi_files, path)
                else:
                    sheet = (
                        safe_sheet_name(os.path.splitext(os.path.basename(self.single_path))[0])
                        if self.single_path else "DiskIO"
                    )
                    out = write_disk_sheet(self.rows_base, path, sheet_name=sheet)
                self.status.set("✅ Saved → " + os.path.basename(out))
            except Exception as e:
                messagebox.showerror("Save failed", str(e))


# ──────────────────────────────────────────────────────────────────────────────
# Tests (sanity checks)
# ──────────────────────────────────────────────────────────────────────────────
SAMPLE_TXT = (
    "Process  PID  I/O Read Bytes  I/O Write Bytes  I/O Other Bytes\n"
    "StartMenuExperienceHost.exe 7404 4.6 MB 120.3 KB 93.0 KB\n"
    "SearchHost.exe 3088 7.9 MB 3.2 MB 859.1 KB\n"
    "msedgewebview2.exe 3880 17.6 MB 5.7 MB 2.2 MB\n"
)


def run_tests() -> int:
    import tempfile

    fails = 0

    rows = parse_disk_text(SAMPLE_TXT)
    try:
        assert len(rows) == 3
        assert rows[0]["Process"].startswith("StartMenuExperienceHost")
    except AssertionError as e:
        print("[FAIL] parse:", e); fails += 1

    try:
        calc = add_calculated_columns(rows)
        total = sum(r["Total Bytes (B)"] for r in calc)
        assert total > 0 and all(isinstance(r["Total Bytes (B)"], int) for r in calc)
        pct_sum = sum(r["Total Usage of I/O in 100%"] for r in calc)
        assert 0.999 <= pct_sum <= 1.001
    except AssertionError as e:
        print("[FAIL] totals:", e); fails += 1

    try:
        from openpyxl import load_workbook
        with tempfile.NamedTemporaryFile(delete=False, suffix=".xlsx") as tmp:
            path = tmp.name
        out = write_disk_sheet(rows, path, sheet_name="DiskIO")
        wb = load_workbook(out)
        assert "DiskIO" in wb.sheetnames
        ws = wb["DiskIO"]
        # Confirm formulas placed
        hdrs = [ws.cell(1, c).value for c in range(1, ws.max_column + 1)]
        cum_col = hdrs.index("Cumulative Total Bytes") + 1
        assert isinstance(ws.cell(2, cum_col).value, str) and ws.cell(2, cum_col).value.startswith("=")
    except Exception as e:
        print("[WARN] excel smoke test skipped or failed:", e)

    if fails:
        print(f"{fails} test(s) failed"); return 1
    print("All tests passed ✅"); return 0


# ──────────────────────────────────────────────────────────────────────────────
# CLI entry
# ──────────────────────────────────────────────────────────────────────────────

def _smart_paths(arg_i, arg_o: Optional[str]) -> Tuple[List[str], str]:
    # Provided args
    if arg_i:
        inputs = arg_i if isinstance(arg_i, list) else [arg_i]
        out = arg_o if (arg_o and arg_o.lower().endswith(".xlsx")) else ((arg_o + ".xlsx") if arg_o else "io_report.xlsx")
        return inputs, out

    # Default input if present
    default_in = os.path.abspath("disk_io.txt")
    if os.path.exists(default_in):
        return [default_in], (arg_o or "io_report.xlsx")

    # Tk picker if available
    try:
        import tkinter as _tk  # type: ignore
        from tkinter import filedialog as _fd  # type: ignore
        root = _tk.Tk(); root.withdraw()
        in_paths = _fd.askopenfilenames(title="Select Disk I/O .txt files", filetypes=[("Text", "*.txt;*.log;*.*")])
        if not in_paths:
            raise RuntimeError("Input path(s) not provided.")
        out_path = arg_o or _fd.asksaveasfilename(title="Save Excel workbook", defaultextension=".xlsx", filetypes=[("Excel", "*.xlsx")])
        if not out_path:
            raise RuntimeError("Output path not provided.")
        root.destroy(); return list(in_paths), out_path
    except Exception:
        # Prompt fallback
        try:
            paths = input("Enter input .txt path(s), separated by ; : ").strip()
            inputs = [p.strip() for p in paths.split(";") if p.strip()]
            if not inputs:
                raise RuntimeError("Input path(s) not provided.")
            out = arg_o or (input("Enter output .xlsx path (default io_report.xlsx): ").strip() or "io_report.xlsx")
            return inputs, out
        except Exception as e:
            raise RuntimeError("No input/output provided. Use -i <file1> <file2> -o <file.xlsx>.") from e


def main(argv: Optional[List[str]] = None) -> int:
    ap = argparse.ArgumentParser(description="Parse Disk I/O TXT and write sheets to Excel.")
    ap.add_argument("--cli", action="store_true", help="Force CLI mode (disable GUI)")
    ap.add_argument("-i", "--input", nargs="+", help="Path(s) to input .txt (one or more)")
    ap.add_argument("-o", "--output", help="Path to output .xlsx (each input becomes its own sheet)")
    ap.add_argument("--run-tests", action="store_true", help="Run self-tests and exit")
    args = ap.parse_args(argv)

    if args.run_tests:
        return run_tests()

    if not args.cli and TK_OK:
        app = App()  # type: ignore[name-defined]
        app.mainloop(); return 0

    # CLI flow
    try:
        in_paths, out_path = _smart_paths(args.input, args.output)
    except RuntimeError as e:
        sys.stderr.write(str(e) + "\n"); sys.stderr.write("Example: python disk_parser.py -i disk1.txt disk2.txt -o out.xlsx\n"); return 2

    if len(in_paths) > 1:
        try:
            out = write_workbook_for_files(in_paths, out_path)
        except Exception as e:
            sys.stderr.write(str(e) + "\n"); return 4
        print(f"✅ Wrote {len(in_paths)} sheets to '{out}'"); return 0

    # Single file path
    single = in_paths[0]
    with open(single, "r", encoding="utf-8", errors="replace") as f:
        raw = f.read()
    rows = parse_disk_text(raw)
    if not rows:
        sys.stderr.write("No rows parsed. Check the input formatting.\n"); return 3

    sname = safe_sheet_name(os.path.splitext(os.path.basename(single))[0])
    try:
        out = write_disk_sheet(rows, out_path, sheet_name=sname)
    except Exception as e:
        sys.stderr.write(str(e) + "\n"); return 4

    print(f"✅ Wrote {len(rows)} rows to '{out}' (sheet '{sname}')"); return 0


if __name__ == "__main__":
    raise SystemExit(main())
